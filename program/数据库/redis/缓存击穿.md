# 现象定义

**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，缓存没有存储对应的key值，直接请求就到了数据库了





```t
每次查询都会直接打到DB
```

bloomfilter 如何解决缓存击穿问题





# 解决方案：

BloomFilter -- 布隆过滤器

概念：布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率




### BloomFilter  缺点

bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性

- 存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。
- 删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用Counting Bloom Filter



## BloomFilter实现

布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。

在==使用bloom filter==时，绕不过的两点是==预估数据量n==以及==期望的误判率fpp==，

在==实现bloom filter==时，绕不过的两点就是==hash函数==的选取以及==bit数组的大小==。



对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数

### (1)Bit数组大小选择

 根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式： 




### (2)哈希函数选择

 由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：





## 使用互斥锁（mutex key）

对更新操作使用互斥锁，get操作不做操作



