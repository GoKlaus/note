# 5/12

## transient关键字

### 补充：

### 1、序列化和反序列化

​			==Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。从而达到网络传输、本地存储的效果。==

​		序列化（Serialization）是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个储存媒介，例如档案或记忆体缓冲等，在网络传输过程中，可以是字节或者XML等格式；而字节或者XML格式的可以还原成完全相等的对象，这个相反的过程又称为反序列化；

### 2、java对象的序列化和反序列化

​		java中创建好了的对象，只要没有被回收都可以反复使用此对象。但是，这些对象都是存储在jvm的堆中(stack)，只有jvm在运行的时候这些对象才是存在的，jvm停止这些对象也就随之消失。在真实场景中，需要将这些对象持久化下来，并且在需要的时候将对象重新读取出来，java的序列化可以帮助实现此功能。

​		java的序列化机制(java serialization)是java语言内建的一种对象持久化方式，通过序列化，可以将对象的状态信息保存在字节数组，并且在有需要的时候将这个字节数组通过反序列化的方式转化成对象 ，对象的序列化可以很容易的在jvm中的活动对象和字节数组(流)之间进行转换，java中对象的序列化和和反序列化被广泛的应用到RMI(远程方法调用)及网络传输中

## RPC

Remote Procedure Call --远程过程调用，被设计为在应用程序间通信的中立方式，它不理会操作系统以及语言之间的差异。即RPC支持多种语言，RMI只支持java写的应用程序

## RMI补充

```
RPC, Remote Procedure Call 即远程过程调用。见名知意：从远程主机调用一个过程/函数。

	RPC 的目标是：使得本程序调用其它远程主机上的函数，好像调用本程序内的函数一样简单，并且屏蔽编程语言的差异性。

	要实现上述目标首先需要设计一种通信协议，这被称为：RPC协议(RPC Protocol)

RPC协议 不是某一个具体的协议，而是一个类型名，代表一类用作RPC的协议。RPC协议是在网络应用层协议，广义上可以跨越平台、语言进行应用间通讯（说广义是因为可以开发一个协议但只支持单个语言）
是否RMI是RPC的一种


```



​		RMI(Remote Mothod Invocation)--调用远程对象方法，允许返回java对象以及基本数据类型。而RPC不支持对象的概念，传送到RPC服务的消息由外部数据表示(External Data Representation，XDR)语言表示，这种语言抽象了字节序类和数据结构之间的差异。只有有==XDR定义的数据类型才能被传递==，RPC不允许传递对象。可以说RMI是面向对象的RPC。

​		RPC和RMI之间的最主要区别在于方法是如何被调用的。在RMI中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新的方法就不能被RMI客户方所调用。

​		RPC中，当一个请求到达RPC服务器时，这个请求就包含了一个参数集和一个文本值，通常形成classname.methodname的形式。这就向RPC服务器表明，被请求的方法在为classname的类中，名叫methodname。然后RPC就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是相匹配的，一旦匹配成功，这个方法就被调用了，其结果被编码后返回客户方。

​		分布式计算系统要求运行在不同主机上的对象相互调用。各种分布式系统都有自己的调用协议，如CORBA的IIOP(Internet InterORB Protocol)，MTS的DCOM。EJB的组件--java中提供了完整的socket通讯接口，但socket要求客户端和服务端必须进行应用级协议的编码交换数据，所以采用socket相较而言比较麻烦。

​		RPC可以代替socket，抽象出通讯接口用于过程调用，使得编程者调用一个远程过程和一个本地过程同样方便。RPC系统采用XDR来编码远程调用的参数和返回值。

​		RPC不支持对象，而EJB构造的是完全面向对象的分布式系统，所以面向对象的远程调用RMI(Remote Method Invocation)。RMI是采用JRMP(Java Remote Method Protocol)通讯协议，是构建在TCP/IP协议上的一种远程调用方法。

==总结：==

|          | RPC(Remote Procedure Call) | RMI(Remote Mothod Invocation)             |
| -------- | -------------------------- | ----------------------------------------- |
|          | 远程过程调用               | 调用远程对象方法                          |
| 支持对象 | 不支持                     | 支持                                      |
| 采用协议 |                            | JRMP(Java Remote Method Protocol)通讯协议 |
| 支持语言 | 跨语言，平台               | java                                      |
|          |                            |                                           |
|          |                            |                                           |
|          |                            |                                           |
|          |                            |                                           |
|          |                            |                                           |



dubbo共支持如下几种通信协议：

- [dubbo://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-dubbo%3A%2F%2F)
- [rmi://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-rmi%3A%2F%2F)
- [hessian://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-hessian%3A%2F%2F)
- [http://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-http%3A%2F%2F)
- [webservice://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-webservice%3A%2F%2F)
- [thrift://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-thrift%3A%2F%2F)
- [memcached://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-memcached%3A%2F%2F)
- [redis://](http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-redis%3A%2F%2F)









### 3、序列化及反序列化相关接口及类

```java
java.io.Serializable;
java.io.Externalizable;
```

#### Serializable和Externalizable

不采用第三方工具包来完成序列化的情形下讨论：

==要实现java对象的序列化和反序列化，通过实现Serializable和Externalizable接口即可==。



### JDK8 关于Serializable接口

serializable接口是一个标记接口，没有任何方法和字段，仅用于标识可串行化的语义，不实现此接口的类将不会使任何状态序列化或反序列化。可序列化的子类型都是可序列化的。



为了允许序列化不可序列化的子类型，子类型可能承担保存和回复超类型的公共，受保护和(如果可访问)包字段的状态的责任，只有当他扩展的类具有可访问的无参构造函数来初始化类的状态。如果不是这样，声明一个类Serializable是一个错误。错误将在运行时检测到。

```
对这里的这段话不太理解：序列化不可序列化的子类型，子类型可能承担保存和回复超类型的公共，受保护和(如果可访问)包字段的状态的责任
```

在反序列化期间，非可序列化类的字段将使用该类的public和protected no-arg构造函数进行初始化。对于可序列化的子类，必须可以访问no-arg函数。可序列化子类的字段将从流中回复。











在序列化和反序列化过程中需要特殊处理的类必须采用具有这些精确签名的特殊方法：

```java
private void writeObject(java.io.ObjectOutputStream out) throw IOException;
private void readObject(java.io.ObjectInputStream in) throw IOException,ClassNotFoundException;
private void readObjectNoData() throw ObjectStreamExcepiton;
```

writeObject方法负责为特定的类编写类的状态，以便相应的readObject方法可以恢复它。可以通过调用out.defaultWriteObject来调用保存对象字段的默认机制。该方法不需要关注其超类或者子类的状态。通过writeObject或者通过使用DataOutput支持的原始数据类型将各个字段写入ObjectOutputStream来保存状态。





## 1、transient的作用和用法

​		java对象只要实现了Serializable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关心具体序列化的过程，只要这个类实现了Serializable接口，这个类的所有属性和方法都会自动序列化。

​		实际中，会有部分属性需要序列化，其他属性不需要序列化，例如用户的敏感信息(身份证，银行卡号)，为了安全起见，不希望在网络操作(主要涉及到序列化操作，本地序列化缓存 也适用)中被传输，就可以使用transient关键字。即，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里被持久化。

​		 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

```
总结：
声明属性不会被序列化
```

## 2、 transient使用小结

1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。

2）transient关键字==只能修饰变量，而不能修饰方法和类==。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。

3）被transient关键字修饰的变量不再能被序列化，==一个静态变量不管是否被transient修饰，均不能被序列化==

```
总结：
1、static修饰(静态变量)变量，本身就不能被序列化--可以看做static默认带有transient修饰
2、
```

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @description 使用transient关键字不序列化某个变量
 *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致
 *        
 * @author Alexia
 * @date  2013-10-15
 */
public class TransientTest {
    
    public static void main(String[] args) {
        
        User user = new User();
        user.setUsername("Alexia");
        user.setPasswd("123456");
        
        System.out.println("read before Serializable: ");
        System.out.println("username: " + user.getUsername());
        System.err.println("password: " + user.getPasswd());
        
        try {
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream("C:/user.txt"));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            // 在反序列化之前改变username的值
            User.username = "jmwang";
            
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    "C:/user.txt"));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println("\nread after Serializable: ");
            System.out.println("username: " + user.getUsername());
            System.err.println("password: " + user.getPasswd());
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    public static String username;
    private transient String passwd;
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

}
```





# 5/23

## 如何减少开发中的bug

bug是不可避免的，开发中应该遵循一套原则来尽量避免明显的， 不该出现的

### 2/8原则

80%的代码用来处理异常情况，如果代码的异常逻辑很少，说明代码不完善。
80%的时间思考

### 2个技巧 

防御性编程
不相信任何人的代码，检查所有输入和返回值，处理所有异常
代码写三遍
第一遍将逻辑写通
第二遍完善代码：检查是否遗漏的异常没有处理，是否有富案件的地方日志没有加，是否不符合编程规范
第三遍优化代码：逻辑是否可以优化，某些处理是否可以用更好的方式

### 三个条件

熟悉编程语言
单元测试
熟悉业务





